import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Collections;



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Kent Huang
 * 2015.1.15
 * A game called reversi.
 */
public class reversi extends javax.swing.JFrame {

    /**
     * Creates new form reversi
     */
    //used to save the last position so the box will be red after each move
    int num1,num2;
    //create Array that stores status of every box on the board
    int[][]stateArray=new int[8][8];
    //For each box that is able to put a disc, the information of that box will 
    //be added to the ArrayList
    ArrayList<int[]>analyzeArray=new ArrayList<>();
    //stores result of placing disc into each box
    ArrayList<boolean[]>moveResult=new ArrayList<>();
    //ArrayList that stores the previous stateArrays for redo
    ArrayList<int[][]>redoArray=new ArrayList<>();
    //each element in this array represents
    //{discs on right can be taken,left,up,down,upright,downleft,upleft,downright}
    boolean[]result=new boolean[]{false,false,false,false,false,false,false,false};
    //blackNum stores number of black discs, whiteNum store white number
    //Index stores the index of analyzeArray that needed to call during computer move
    //nextMove is used to store whether white or black will move next
    int blackNum,whiteNum,index=0,nextMove=1;
    //used later for input checking
    String input;
    
    public reversi() {
        
        initComponents();  
        //Set texts on the label, create a new line using <br> in <html>
        verticalLabel.setText("<html>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8</html>");
        //set text for the one on the left
        verticalLabel1.setText(verticalLabel.getText());
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        gameFrame = new javax.swing.JFrame();
        board = new javax.swing.JPanel();
        discBut = new javax.swing.JButton();
        inputField = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        startBut = new javax.swing.JButton();
        exitBut = new javax.swing.JButton();
        jLabel6 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        whiteScoreLabel = new javax.swing.JLabel();
        horizontalLabel = new javax.swing.JLabel();
        verticalLabel = new javax.swing.JLabel();
        verticalLabel1 = new javax.swing.JLabel();
        horizontalLabel1 = new javax.swing.JLabel();
        outputLabel = new javax.swing.JLabel();
        blackScoreLabel = new javax.swing.JLabel();
        redoBut = new javax.swing.JButton();
        instructionFrame = new javax.swing.JFrame();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        closeBut = new javax.swing.JButton();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        difficultyBox = new javax.swing.JComboBox();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        playerNumBox = new javax.swing.JComboBox();
        colorBox = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        saveBut = new javax.swing.JButton();
        instructionLabel = new javax.swing.JLabel();

        gameFrame.setMinimumSize(new java.awt.Dimension(430, 400));
        gameFrame.setResizable(false);

        board.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        board.setPreferredSize(new java.awt.Dimension(241, 241));
        board.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                boardMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout boardLayout = new javax.swing.GroupLayout(board);
        board.setLayout(boardLayout);
        boardLayout.setHorizontalGroup(
            boardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 239, Short.MAX_VALUE)
        );
        boardLayout.setVerticalGroup(
            boardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 239, Short.MAX_VALUE)
        );

        discBut.setText("Move");
        discBut.setActionCommand("");
        discBut.setEnabled(false);
        discBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                discButActionPerformed(evt);
            }
        });

        inputField.setEditable(false);
        inputField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                inputFieldKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                inputFieldKeyReleased(evt);
            }
        });

        jLabel1.setText("Position:");

        startBut.setText("Start");
        startBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButActionPerformed(evt);
            }
        });

        exitBut.setText("Exit");
        exitBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitButActionPerformed(evt);
            }
        });

        jLabel6.setText("White");

        jLabel5.setText("Black");

        whiteScoreLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        whiteScoreLabel.setText("2");

        horizontalLabel.setText(" a        b        c        d        e       f        g       h");

        verticalLabel.setText("1");
        verticalLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        verticalLabel1.setText("1");
        verticalLabel1.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        horizontalLabel1.setText(" a        b        c        d        e       f        g       h");

        outputLabel.setMaximumSize(new java.awt.Dimension(180, 34));

        blackScoreLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        blackScoreLabel.setText("2");

        redoBut.setText("Redo");
        redoBut.setActionCommand("");
        redoBut.setEnabled(false);
        redoBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                redoButActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout gameFrameLayout = new javax.swing.GroupLayout(gameFrame.getContentPane());
        gameFrame.getContentPane().setLayout(gameFrameLayout);
        gameFrameLayout.setHorizontalGroup(
            gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameFrameLayout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel6, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(whiteScoreLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(verticalLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(gameFrameLayout.createSequentialGroup()
                        .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addGroup(gameFrameLayout.createSequentialGroup()
                                    .addComponent(startBut)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jLabel1)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(inputField, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(discBut, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameFrameLayout.createSequentialGroup()
                                    .addGap(10, 10, 10)
                                    .addComponent(outputLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(exitBut, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addComponent(board, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(gameFrameLayout.createSequentialGroup()
                                .addComponent(verticalLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(blackScoreLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addComponent(redoBut, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(gameFrameLayout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(horizontalLabel1))))
            .addGroup(gameFrameLayout.createSequentialGroup()
                .addGap(88, 88, 88)
                .addComponent(horizontalLabel))
        );
        gameFrameLayout.setVerticalGroup(
            gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameFrameLayout.createSequentialGroup()
                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(gameFrameLayout.createSequentialGroup()
                        .addComponent(horizontalLabel)
                        .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(gameFrameLayout.createSequentialGroup()
                                .addGap(82, 82, 82)
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(blackScoreLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(gameFrameLayout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(board, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addComponent(verticalLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 241, Short.MAX_VALUE)
                                        .addComponent(verticalLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))
                    .addGroup(gameFrameLayout.createSequentialGroup()
                        .addGap(93, 93, 93)
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(whiteScoreLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(horizontalLabel1)
                .addGap(18, 18, 18)
                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(discBut)
                    .addComponent(inputField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1)
                    .addComponent(startBut)
                    .addComponent(redoBut))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(gameFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(gameFrameLayout.createSequentialGroup()
                        .addComponent(exitBut)
                        .addContainerGap())
                    .addComponent(outputLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        instructionFrame.setMinimumSize(new java.awt.Dimension(370, 350));
        instructionFrame.setResizable(false);

        jLabel8.setText("Place your piece on an empty square so that one");

        jLabel9.setText("Caputuring is the only valid moves.");

        jLabel10.setText("You win by having more of your pieces than");

        jLabel11.setText(" (or more) of the opponent's pieces are between yours.");

        jLabel12.setText(" If you can't, then the game ends.");

        jLabel13.setText(" the opponents at the end of the game.");

        closeBut.setText("Close");
        closeBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButActionPerformed(evt);
            }
        });

        jLabel14.setText("Instruction");

        jLabel15.setText("Input Requirement");

        jLabel16.setText("Input a letter, then a number, coresponding to the box");

        jLabel17.setText("That you want to place your disc in. For example, f4.");

        jLabel18.setText("Everything else will be considered invalid.");

        jLabel19.setText("You may also click on the box then click move button.");

        javax.swing.GroupLayout instructionFrameLayout = new javax.swing.GroupLayout(instructionFrame.getContentPane());
        instructionFrame.getContentPane().setLayout(instructionFrameLayout);
        instructionFrameLayout.setHorizontalGroup(
            instructionFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(instructionFrameLayout.createSequentialGroup()
                .addGroup(instructionFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(instructionFrameLayout.createSequentialGroup()
                        .addGap(22, 22, 22)
                        .addGroup(instructionFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel13)
                            .addComponent(jLabel12)
                            .addComponent(jLabel11)
                            .addComponent(jLabel10)
                            .addComponent(jLabel9)
                            .addComponent(jLabel8)
                            .addComponent(jLabel16)
                            .addComponent(jLabel17)
                            .addComponent(jLabel18)
                            .addComponent(jLabel19)))
                    .addGroup(instructionFrameLayout.createSequentialGroup()
                        .addGap(119, 119, 119)
                        .addComponent(jLabel14))
                    .addGroup(instructionFrameLayout.createSequentialGroup()
                        .addGap(119, 119, 119)
                        .addComponent(closeBut))
                    .addGroup(instructionFrameLayout.createSequentialGroup()
                        .addGap(105, 105, 105)
                        .addComponent(jLabel15)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        instructionFrameLayout.setVerticalGroup(
            instructionFrameLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(instructionFrameLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel14)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel11)
                .addGap(11, 11, 11)
                .addComponent(jLabel9)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel12)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel13)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel15)
                .addGap(5, 5, 5)
                .addComponent(jLabel16)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel17)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel18)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel19)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(closeBut)
                .addContainerGap())
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(200, 223));
        setResizable(false);

        difficultyBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Hard", "Normal", "Easy" }));

        jLabel2.setText("Setting");

        jLabel3.setText("Difficulty:");

        playerNumBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1 Player", "2 Player" }));
        playerNumBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                playerNumBoxItemStateChanged(evt);
            }
        });

        colorBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Black", "White" }));

        jLabel4.setText("Your color:");

        saveBut.setText("Save");
        saveBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveButActionPerformed(evt);
            }
        });

        instructionLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        instructionLabel.setText("How To Play?");
        instructionLabel.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        instructionLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                instructionLabelMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(saveBut)
                .addGap(69, 69, 69))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(79, 79, 79)
                        .addComponent(jLabel2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(43, 43, 43)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(instructionLabel)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jLabel4)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(colorBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jLabel3)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(difficultyBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(65, 65, 65)
                        .addComponent(playerNumBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(43, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(playerNumBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(17, 17, 17)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(difficultyBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(colorBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addGap(18, 18, 18)
                .addComponent(saveBut)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(instructionLabel)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    /**function for drawing the board
     * passing no parameters
     * returns nothing
     */
    public void draw(){
        //create Graphics variable tograph the board
        Graphics graph=board.getGraphics();
        //Set pen color to white to draw the background
        graph.setColor(new Color(240,240,240));
        //draw background, a 240*240 square filled with white
        graph.fillRect(0, 0, 240, 240);
        //Set pen color to black
        graph.setColor(new Color(0,0,0));
        //draw the border of the board
        graph.drawRect(0, 0, 241, 241);
        //this loop runs the code in it 7 times
        for(int i=1;i<8;i++){
            //draw vertical black lines with 30 pixels space in between
            graph.drawLine(i*30, 0, i*30, 240);
            //draw horizontal black lines with 30 pixels space in between
            graph.drawLine(0, i*30, 240, i*30);
        }
        //these loops run the code in it 64 times, which checks each box on the board
        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                //if the box is occpied after the previous move
                if(i==num1&&j==num2){
                    //change pen color to red
                    graph.setColor(new Color(255,0,0));
                    //paint the box in red
                    graph.fillRect(i*30+1, j*30+1, 29, 29);
                    //change pen color back to black
                    graph.setColor(new Color(0,0,0));
                }
                //if the state array shows that tis box has white disc
                if(stateArray[i][j]==1){
                    //draw a black circle with no color filled
                    graph.drawOval(i*30+5, j*30+5, 20, 20);
                }
                //if the state array shows that tis box has black disc
                if(stateArray[i][j]==-1){
                    //draw a black circle filled with black
                    graph.fillOval(i*30+5, j*30+5, 20, 20);
                }                  
            }
        }
    }    
    /**read user input, analyze if it's valid and output result on board
     * no parameters
     * returns nothing
     */
    public void makeMove(){
        //try catch statement to detect invalid input
        try{
            //declear a new array inside the function so when added to the Arraylist,
            //the elements in ArrayList will not change when the variable changes
            int[][]redo=new int[8][8];
            //go through both redo and stateArray to set them equal
            for(int i=0;i<8;i++){
                for(int j=0;j<8;j++){
                    redo[i][j]=stateArray[i][j];
                }
            }
            //add redo to redoArray
            redoArray.add(redo);
            //if there are two players and only one element added, redo is not possible
            //because only one move occoured
            if(!(((String)playerNumBox.getSelectedItem()).equals("2 Player")&&redoArray.size()==1)){
                redoBut.setEnabled(true);
            }
            //reset output label in case if there is a error message initially
            outputLabel.setText("");
            //draw the board before placing disc in case the user inputs invalid move
            draw();
            //split the input in to a char array with the first element being
            //the letter and the second one being the number
            char[] playerMoveIn=inputField.getText().toCharArray();
            //these two arrays stores which box the player or computer will move in
            int[] player=new int[2];
            int[] computer;
            //read the letter part of the input and trun into corresponding number on board\
            //the ASCII code for th letter will have a corresponding number
            //with 65 being A and 97 being a
            if((int)playerMoveIn[0]<105&&(int)playerMoveIn[0]>96){
                //subtract 97 to get 0 for 'a', 1 for 'b', etc
                player[0]=(int)playerMoveIn[0]-97;
            }else if((int)playerMoveIn[0]<73&&(int)playerMoveIn[0]>64){
                //subtract 65 to get 0 for 'A', 1 for 'B', etc
                player[0]=(int)playerMoveIn[0]-65;
            //if first letter of user input is not A-H or a-h, output error message and end this method
            }else{
                outputLabel.setText("<html>Invalid input, the first character should be a letter between a and h.</html>");
                return;
            }
            //read the number part of the input, minus one due to the index of
            //the array is different from the index on board
            player[1]=Integer.parseInt(String.valueOf(playerMoveIn[1]))-1;
            //this loop goes through the analyze array which is initialized 
            //when start button is pushed
            for(int i=0;i<analyzeArray.size();i++){
                //Check if the user input is the same as one coordinate in analyzeArray
                //and save the corresponding index that can get more information
                //from other arrays
                if(player[0]==analyzeArray.get(i)[0]&&player[1]==analyzeArray.get(i)[1]){
                    index=i;
                    //break the loop once found the required index
                    break;
                }
            }
            //pass the information of player's move into the place disc function
            //and place the disc onto the board 
            placeDisc(player,nextMove,moveResult.get(index));
            //if the move is invalid, stop this method and ask for input again
            if(outputLabel.getText().equals("<html>Invalid move, you must take at least one disc.</html>")){
                return;
            }
            //clear the arraylists for next move
            analyzeArray.clear();
            moveResult.clear();
            draw();
            //-1*nextmove represent the opposite color of the player
            boardAnalyze(-1*nextMove);
            //Check if the game ended for the color opposite of the user
            if(!winningCheck(-1*nextMove).equals("")){
                //if so, output winning message and stop this method
                outputLabel.setText(winningCheck(-1*nextMove));
                return;
            }
            //the if statement runs if the user choosed 1 player before game starts
            if(((String)playerNumBox.getSelectedItem()).equals("1 Player")){
                //stop the main function for 1 second so user can see his own move
                Thread.sleep(1000);
                //due to 1 player, computer will move with a color opposite of
                //user's color, -1*nextMove
                computer=computerMove(-1*nextMove);
                //get computer's move from a method and do the same thing as for the player's move
                for(int i=0;i<analyzeArray.size();i++){
                    if(computer[0]==analyzeArray.get(i)[0]&&computer[1]==analyzeArray.get(i)[1]){
                        index=i;
                        break;
                    }
                }
                placeDisc(computer,-1*nextMove,moveResult.get(index));
                analyzeArray.clear();
                moveResult.clear();
                draw();
                //analyze the board for the user
                boardAnalyze(nextMove);
                //Check if the game ended for the user
                if(!winningCheck(nextMove).equals("")){
                    //if so, output winning message and stop this method
                    outputLabel.setText(winningCheck(nextMove));
                }
            }else{
                //if the user choosed 2 players, change the color to the opposite
                //and ask for user input from the other player
                nextMove=-1*nextMove;
            }
        //use Exception instead of NumberFormat Exception in case the user input
        //less than two character or the second character is not number
        }catch(Exception e){
            outputLabel.setText("<html>Invalid input, the second character should be a number.</html>");
        }
    }
    /**A function for checking if the game ended
     * @param n if n=1, analyze for white, if n=-1, analyze for black
     * @return winning message
     */
    public String winningCheck(int n){
        //the loop goes through the 2D array and check if there's any move possible
        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                if(stateArray[i][j]==2*n){
                    //if there are still moves possible return nothing
                    return"";
                }
            }
        }
        //reset everything if the game is over, change nextMov to 1 so black starts first
        discBut.setEnabled(false);
        startBut.setEnabled(true);
        //the user will not be able to redo when the game ended
        redoBut.setEnabled(false);
        nextMove=1;
        //if the number of white discs is bigger ,say white wins
        if(whiteNum>blackNum){
            return "White wins.";
        //if black has more then black wins
        }else if(blackNum>whiteNum){
            return "Black wins.";
        //otherwise tie
        }else{
            return "Tie.";
        }
    }
    /**The function that change the stateArray after moving
     * @param a the array that stores the coordinate of the box
     * @param n the color of the disc
     * @param b the resultArray that tells the discs on which side will be taken 
     * return nothing
     */
    public void placeDisc(int[] a,int n,boolean[] b){
        //k,l are temporary integers used for columns and rows
        int k,l;
        //a[0]a[1]is the position of user input
        //if the position in stateArray is 2 or -2, this move is valid
        if(stateArray[a[0]][a[1]]==n*2){
            //this position will be occupied by the disc
            stateArray[a[0]][a[1]]=n;
            //If the result array shows that the discs on the right can be taken
            if(b[0]){
                //[k][a[1]]will be the position of the ones on the right
                //starting with [a[0]+1][a[1]]
                k=a[0]+1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[k][a[1]]==-1*n){
                    stateArray[k][a[1]]=n;
                    //k++ gives the position on the right
                    k++;
                }
            }
            //If the result array shows that the discs on the left can be taken
            if(b[1]){
                //[k][a[1]]will be the position of the ones on the left
                //starting with [a[0]-1][a[1]]
                k=a[0]-1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[k][a[1]]==-1*n){
                    stateArray[k][a[1]]=n;
                    //k-- gives the position on the left
                    k--;
                }
            }
            //If the result array shows that the discs on the top can be taken
            if(b[2]){
                //[a[0]][l]will be the position of the ones on the top
                //starting with [a[0]][a[1]+1]
                l=a[1]+1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[a[0]][l]==-1*n){
                    stateArray[a[0]][l]=n;
                    //l++ gives the position on the top
                    l++;
                }
            }
            //If the result array shows that the discs on the bottom can be taken
            if(b[3]){
                //[a[0]][l]will be the position of the ones on the bottom
                //starting with [a[0]][a[1]-1]
                l=a[1]-1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[a[0]][l]==-1*n){
                    stateArray[a[0]][l]=n;
                    //l-- gives the position on the bottom
                    l--;
                }
            }
            //If the result array shows that the discs on the top right can be taken
            if(b[4]){
                //[k][l]will be the position of the ones on the top right
                //starting with [a[0]+1][a[1]+1]
                k=a[0]+1;
                l=a[1]+1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[k][l]==-1*n){
                    stateArray[k][l]=n;
                    //k++,l++ gives the position on the top right
                    k++;
                    l++;
                }
            }
            //If the result array shows that the discs on the bottom left can be taken
            if(b[5]){
                //[k][l]will be the position of the ones on the bottom left
                //starting with [a[0]-1][a[1]-1]
                k=a[0]-1;
                l=a[1]-1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[k][l]==-1*n){
                    stateArray[k][l]=n;
                    //k--,l-- gives the position on the bottom left
                    k--;
                    l--;
                }
            }
            //If the result array shows that the discs on the bottom right can be taken
            if(b[6]){
                //[k][l]will be the position of the ones on the bottom right
                //starting with [a[0]+1][a[1]-1]
                k=a[0]+1;
                l=a[1]-1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[k][l]==-1*n){
                    stateArray[k][l]=n;
                    //k++,l-- gives the position on the bottom right
                    k++;
                    l--;
                }
            }
            //If the result array shows that the discs on the top left can be taken
            if(b[7]){
                //[k][l]will be the position of the ones on the top left
                //starting with [a[0]-1][a[1]+1]
                k=a[0]-1;
                l=a[1]+1;
                //as long as the disc is opposite colour, turn it to the user's color
                while(stateArray[k][l]==-1*n){
                    stateArray[k][l]=n;
                    //k--,l++ gives the position on the top left
                    k--;
                    l++;
                }
            }
            num1=a[0];
            num2=a[1];
        //if this position is 1,-1,or 0, the move is invalid.
        }else{
            outputLabel.setText("<html>Invalid move, you must take at least one disc.</html>");
        }
        //reset numbers of black and white
        blackNum=0;whiteNum=0;
        //this loop goes through ever box on the board
        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                //if the stateArray shows 1, its white and white number plus one
                if(stateArray[i][j]==1){
                    whiteNum++;
                //if the stateArray shows -1, its black and black number plus one
                }else if(stateArray[i][j]==-1){
                    blackNum++;
                }
            }
        }
        //output the number of each color
        blackScoreLabel.setText(String.valueOf(blackNum));
        whiteScoreLabel.setText(String.valueOf(whiteNum));
    }
    /**the function is to calculate which box the computer will move in
     * @param n a number that represents color
     * @return an array storing the position
     */
    public int[] computerMove(int n){
        int[] a,temp;
        ArrayList<int[]> indexs=new ArrayList<>();
        //this loop goes through the analyzeArray which stores arrays
        for(int i=0;i<analyzeArray.size();i++){
            //store each array in a, and add an array, made of the third element
            //of a and the index of a
            //the second element of a, a[2], is the number of opposite discs it can take
            //after moving into corresponding box
            a=analyzeArray.get(i);
            indexs.add(new int[]{a[2],i});
        }
        //shuffle the arraylist to add randomness of this game
        Collections.shuffle(indexs);
        //The loop goes through index, then do that the same time as the size of index
        for(int i=0;i<indexs.size()-1;i++){
            for(int j=0;j<indexs.size()-1;j++){
                //if the next element is greater than this element, exchange the two
                //doing this the same time as the size of index will sort
                //the arrays in it from big to small by their first element
                //which means if computer move to the first one, it will take
                //greatest number of opponent's discs
                if (indexs.get(j)[0]<indexs.get(j+1)[0]){
                    temp=indexs.get(j);
                    indexs.set(j,indexs.get(j+1));
                    indexs.set(j+1,temp);
                }
            }
        }
        switch ((String)difficultyBox.getSelectedItem()) {
            //if the mode is hard, computer will take most number of opponent's disc
            case "Hard":
                index=indexs.get(0)[1];
                break;
            //if the mode is normal, computer will take mid number of opponent's disc
            case "Normal":
                index=indexs.get(indexs.size()/2)[1];
                break;
            //if the mode is easy, computer will take least number of opponent's disc
            default:
                index=indexs.get(indexs.size()-1)[1];
                break;
        }
        //return the array that stores the position of that box
        return analyzeArray.get(index);
    }
    private void saveButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveButActionPerformed
        //initialize the game frame
        gameFrame.setVisible(true); 
        //close the setting frame
        this.setVisible(false);    
        //set size of the frame
        gameFrame.setMinimumSize(new java.awt.Dimension(430, 415));
    }//GEN-LAST:event_saveButActionPerformed
    /**A function that resets array when game starts
     * takes in nothing
     * returns nothing
     */
    public void resetArray(){
        //the loops go through the 2D array and set everything to zero
        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                stateArray[i][j]=0;
            }
        }
        //set the initial 4 discs on board
        stateArray[3][3]=1;
        stateArray[4][4]=1;
        stateArray[3][4]=-1;
        stateArray[4][3]=-1;
        //clear the redoArray
        redoArray.clear();
    }
    /**
     * oppositeTakenCalc calculates how many opposite colored discs can be taken when move there
     * @param i horizontal position
     * @param j vertical position
     * @param n color of the disc
     * @return the number of opposite colored discs taken
     */
    public int oppositeTakenCalc(int i,int j,int n){
        //due to big amount of variable in each analyzation, simplyfying will make the processing time much longer
        int k,l,oppositeTaken=0,count=0;
        //if there is more than two spaces on the right of this position,
        if(i<6){
            //starting from the one on the right
            k=i+1;
            //if it is the opposite colour,
            if(stateArray[k][j]==-1*n){
                while(k<7&&stateArray[k][j]==-1*n){
                    //go right until the border or if its not opposite colour
                    k++;
                    //add one to count for each opposite disc met
                    count++;
                }
                //if in the end there is a same coloured disc
                if(stateArray[k][j]==n){
                    //make this position a valid position
                    stateArray[i][j]=n*2;
                    //tell resultArray that there is discs avalible on the right
                    result[0]=true;
                    //add count to the total number
                    oppositeTaken+=count;
                    //reset count
                    count=0;
                }else{
                    //otherwise reset count without adding it to the total
                    count=0;
                }
            }
        }
        //if there is more than two spaces on the left of this position
        if(i>1){
            //starting from the one on the right
            k=i-1;
            //if it is the opposite colour,
            if(stateArray[k][j]==-1*n){
                //go left until the border or if its not opposite colour
                while(k>0&&stateArray[k][j]==-1*n){
                    k--;
                    //add one to count for each opposite disc met
                    count++;
                }
                //if in the end there is a same coloured disc
                if(stateArray[k][j]==n){
                    //make this position a valid position
                    stateArray[i][j]=n*2;
                    //tell resultArray that there is discs avalible on the left
                    result[1]=true;
                    //add count to the total number
                    oppositeTaken+=count;
                    //reset count
                    count=0;
                }else{
                    //otherwise reset count without adding it to the total
                    count=0;
                }
            }
        }
        //do the same thing for top ones
        if(j<6){
            k=j+1;
            if(stateArray[i][k]==-1*n){
                while(k<7&&stateArray[i][k]==-1*n){
                    k++;
                    count++;
                }
                if(stateArray[i][k]==n){
                    stateArray[i][j]=n*2;
                    result[2]=true;
                    oppositeTaken+=count;
                    count=0;
                }else{
                    count=0;
                }
            }
        }
        //do the same thing for bottom ones
        if(j>1){
            k=j-1;
            if(stateArray[i][k]==-1*n){
                while(k>0&&stateArray[i][k]==-1*n){
                    k--;
                    count++;
                }
                if (stateArray[i][k]==n){
                    stateArray[i][j]=n*2;
                    result[3]=true;
                    oppositeTaken+=count;
                    count=0;
                }else{
                    count=0;
                }
            }
        }
        //top right
        if (i<6&&j<6){
            k=i+1;
            l=j+1;
            if(stateArray[k][l]==-1*n) {
                while(k<7&&l<7&&stateArray[k][l]==-1*n) {
                    k++;
                    l++;
                    count++;
                }
                if(stateArray[k][l]==n){
                    stateArray[i][j]=n*2;
                    result[4]=true;
                    oppositeTaken+=count;
                    count=0;
                }else{
                    count=0;
                }
            }
        }
        //bottom left
        if(i>1&&j>1){
            k=i-1;
            l=j-1;
            if(stateArray[k][l]==-1*n){
                while(k>0&&l>0&&stateArray[k][l]==-1*n){
                    k--;
                    l--;
                    count++;
                }
                if(stateArray[k][l]==n){
                    stateArray[i][j]=n*2;
                    result[5]=true;
                    oppositeTaken+=count;
                    count=0;
                }else{
                    count=0;
                }
            }
        }
        //bottom right
        if(i<6&&j>1){
            k=i+1;
            l=j-1;
            if (stateArray[k][l]==-1*n) {
                while(k<7&&l>0&&stateArray[k][l]==-1*n){
                    k++;
                    l--;
                    count++;
                }
                if(stateArray[k][l]==n){
                    stateArray[i][j]=n*2;
                    result[6]=true;
                    oppositeTaken+=count;
                    count=0;
                }else{
                    count=0;
                }
            }
        }
        //top left
        if(i>1&&j<6){
            k=i-1;
            l=j+1;
            if(stateArray[k][l]==-1*n){
                while(k>0&&l<7&&stateArray[k][l]==-1*n){
                    k--;
                    l++;
                    count++;
                }
                if(stateArray[k][l]==n){
                    stateArray[i][j]=n*2;
                    result[7]=true;
                    oppositeTaken+=count;
                }
            }
        }
        return oppositeTaken;
    }
    /**This function and analyzes each box of the board for a disc
     * returns nothing
     * @param n a number for color
     */
    public void boardAnalyze(int n){
        int oppositeTaken;
        //reset the array and make every element 2, or -2 be 0 again
        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                if(stateArray[i][j]==2||stateArray[i][j]==-2){
                    stateArray[i][j]=0;
                }
            }
        }
        //go through the stateArray
        for(int j=0;j<8;j++){
            for(int i=0;i<8;i++){
                //if its 0, it will be potentially valid for a move
                if(stateArray[i][j]==0){
                    //calculate number of opposite discs this position can take
                    oppositeTaken=oppositeTakenCalc(i,j,n);
                    //if its a valid move,
                    if(stateArray[i][j]==n*2&&oppositeTaken!=0){
                        //add this position,and oppositeTaken to analyzeArray as an array
                        analyzeArray.add(new int[]{i,j,oppositeTaken});
                        //add the result(array of booleans) to the move result arrayList
                        moveResult.add(result);
                        //reset the result array
                        result=new boolean[]{false,false,false,false,false,false,false,false};
                    }
                }
            }
        }
    }
    
    private void playerNumBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_playerNumBoxItemStateChanged
        //If choosed 2 player, difficulty and color will not be required
        if(((String)playerNumBox.getSelectedItem()).equals("2 Player")){
            difficultyBox.setEnabled(false);
            colorBox.setEnabled(false);
        }else{
            difficultyBox.setEnabled(true);
            colorBox.setEnabled(true);
        }
    }//GEN-LAST:event_playerNumBoxItemStateChanged

    private void closeButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButActionPerformed
        //close the frame when instruction close button pushed
        instructionFrame.setVisible(false);
    }//GEN-LAST:event_closeButActionPerformed

    private void instructionLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_instructionLabelMouseClicked
        //show instruction when clicked How to play label
        instructionFrame.setVisible(true);
    }//GEN-LAST:event_instructionLabelMouseClicked

    private void exitButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitButActionPerformed
        //close the program when exit button pushed
        System.exit(0);
    }//GEN-LAST:event_exitButActionPerformed

    private void startButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButActionPerformed
        //the user will be able to place discs when pushed start button
        discBut.setEnabled(true);
        //you are not able to start again, you have to exit and enter again to restart
        startBut.setEnabled(false);
        inputField.setEditable(true);
        redoBut.setEnabled(false);
        //initialize the stateArray and redoArray because they need to be
        //cleared before a new game
        resetArray();
        num1=-1;
        num2=-1;
        //if the player plays with computer
        if(((String)playerNumBox.getSelectedItem()).equals("1 Player")){
            //if he chooses himself to be white
            if(((String)colorBox.getSelectedItem()).equals("White")){
                //computer will move first
                int[] computer;
                resetArray();
                //draw the board
                draw();
                //wait for one second to show the user initial board
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                }
                //analyze the board for black discs
                boardAnalyze(-1);
                //calculate where computer will move
                computer=computerMove(-1);
                //search for the index of the position in analyzeArray
                for(int i=0;i<analyzeArray.size();i++){
                    if(computer[0]==analyzeArray.get(i)[0]&&computer[1]==analyzeArray.get(i)[1]){
                        index=i;
                        break;
                    }
                }
                //run placeDisc method to change the stateArray
                placeDisc(computer,-1,moveResult.get(index));
                //reset the arraylists
                analyzeArray.clear();
                moveResult.clear();
                //reset the stateArray so all there left is 1,-1 or 0
                for(int i=0;i<8;i++){
                    for(int j=0;j<8;j++){
                        if(stateArray[i][j]==2||stateArray[i][j]==-2){
                            stateArray[i][j]=0;
                        }
                    }
                }
                //analyze for white
                boardAnalyze(1);
                //if user chooses black, analyze for black and wait for futher input
            }else{
                nextMove=nextMove*-1;
                boardAnalyze(nextMove);
            }
            //if there are two players, analyze for black and wait for futher input
        }else{
            nextMove=nextMove*-1;
            boardAnalyze(nextMove);
        }
        //draw the board after computer moves
        draw();
    }//GEN-LAST:event_startButActionPerformed

    private void inputFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_inputFieldKeyReleased
        //if more than two characters typed, it will return to the one before typing
        if(inputField.getText().length()>2){
            inputField.setText(input);
        }
    }//GEN-LAST:event_inputFieldKeyReleased

    private void inputFieldKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_inputFieldKeyPressed
        //save the input in case the user try to type in more than 2 letters
        input=inputField.getText();
        //after inputing values, press Enter will automaticlly run the code
        //instead of pushing button
        if(evt.getKeyChar()=='\n'){
            makeMove();
            //reset the input field
            inputField.setText("");
        }
    }//GEN-LAST:event_inputFieldKeyPressed

    private void discButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_discButActionPerformed
        //move after pushing button "Move"
        makeMove();
        //reset input text field
        inputField.setText("");
    }//GEN-LAST:event_discButActionPerformed

    private void boardMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_boardMouseClicked
        //get the position of the mouse when its clicked on board panel
        int x=evt.getX(),y=evt.getY();
        //calculate the position of that box and set it in inputfield
        //so when move pressed, the program will run
        inputField.setText(String.valueOf((char)(x/30+97))+String.valueOf(y/30+1));
    }//GEN-LAST:event_boardMouseClicked

    private void redoButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_redoButActionPerformed
        //if there are two player, two elements are added to the arrayList in one
        //turn, so remove one first
        if(((String)playerNumBox.getSelectedItem()).equals("2 Player")){
            redoArray.remove(redoArray.size()-1);
        }
        //go through array and set stateArray to previous move
        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                stateArray[i][j]=redoArray.get(redoArray.size()-1)[i][j];
            }
        }
        //remove the information for previous move
        redoArray.remove(redoArray.size()-1);
        //reset num1 and num2 so the box will not be red when draw
        num1=-1;
        num2=-1;
        //clear the arrays for next move
        analyzeArray.clear();
        moveResult.clear();
        boardAnalyze(nextMove);
        //if there are two players
        if(((String)playerNumBox.getSelectedItem()).equals("2 Player")){
            //if the size of the array is less than 2
            if(redoArray.size()<=1){
                //disable redo button because redo before two moves occouring
                //is not possible
                redoBut.setEnabled(false);
            }
        //if there is one players
        }else{
            //if the size of the array is less than 1
            if(redoArray.size()<1){
                //disable redo button because redo before one user move occouring
                //is not possible
                redoBut.setEnabled(false);
            }
        }
        //draw the board
        draw();
    }//GEN-LAST:event_redoButActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new reversi();
    
    
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(reversi.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(reversi.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(reversi.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(reversi.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new reversi().setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel blackScoreLabel;
    private javax.swing.JPanel board;
    private javax.swing.JButton closeBut;
    private javax.swing.JComboBox colorBox;
    private javax.swing.JComboBox difficultyBox;
    private javax.swing.JButton discBut;
    private javax.swing.JButton exitBut;
    private javax.swing.JFrame gameFrame;
    private javax.swing.JLabel horizontalLabel;
    private javax.swing.JLabel horizontalLabel1;
    private javax.swing.JTextField inputField;
    private javax.swing.JFrame instructionFrame;
    private javax.swing.JLabel instructionLabel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JLabel outputLabel;
    private javax.swing.JComboBox playerNumBox;
    private javax.swing.JButton redoBut;
    private javax.swing.JButton saveBut;
    private javax.swing.JButton startBut;
    private javax.swing.JLabel verticalLabel;
    private javax.swing.JLabel verticalLabel1;
    private javax.swing.JLabel whiteScoreLabel;
    // End of variables declaration//GEN-END:variables
}
